<TYPE>post</TYPE>
<STATUS>publish</STATUS>
<ID>198</ID>
<TITLE>
Read WAV file using C/C++
</TITLE>

<CONTENT>
<strong>This work is derivative of Dr. Taylor's work </strong><a href="http://people.msoe.edu/~taylor/examples/wav.htm">http://people.msoe.edu/~taylor/examples/wav.htm</a> . <strong>There was a bug in his implementation which is removed from this implementation.</strong>

We give here c++ class to read  WAV file and store its content in an array. We also store these values in a ASCII file and plot it using <code>gnuplot</code> to check whether we get it right. <a href="http://www.fon.hum.uva.nl/praat/"><code>praat</code></a> can be used to confirm whether our output is right or not. Google to read about the WAV format. <strong> We only support non-compressed WAV file.</strong>
<h1><strong>WAV File Format</strong></h1>
We do not support compressed WAV file. Format which is programmed here is available here <a href="https://ccrma.stanford.edu/courses/422/projects/WaveFormat/">https://ccrma.stanford.edu/courses/422/projects/WaveFormat/</a>.
<h1>Implementation</h1>
The Makefile project can be found at google code repository available at <a href="https://ee717-iitb.googlecode.com/svn/trunk/project_hindi/">https://ee717-iitb.googlecode.com/svn/trunk/project_hindi/</a> . Make sure you checkout <strong>at rev no 49</strong>. Anyway, we give the implementation here. After compilation (using <code>make all</code> you'll get the binary <code>parseSpeech</code>.  Use this binary <code>./parseSpeech -f </code>. If your wav file is long (more than 3-4 seconds) the txt file generated by this program <code>speechData.txt</code> will be very lengthy. Use can use <code>gnuplot</code> to draw the waveform. <strong>We are sorry for not giving an extensive documentation on this.</strong>

<strong> Make sure all .cc files go in <code>src</code> folder while all .h files are put into <code>include</code> folder.</strong>
<h2>Makefile</h2>
In this makefile, we have commented out special libraries we were using. This makefile should work on your machine. There is no need for fancy libraries right now.

[sourcecode language="c"]

# Makefile for project

# Course Name : EE 717 - Advanced Computing for Electrical Engineers

# ABOUT :

# This parse an wav file and give an txt file which contains the information.

#

# Dilawar, dilawar@ee.iitb.ac.in

# Created on : July Sep 2, 2010

# Modification logs :

CC = g++

CFLAGS = -c -g -Wall  -I /usr/local/include #-I/usr/include/tcl8.5/tk-private/generic

MACRO =  -D DEBUG -D SCILAB1

VPATH = src:../include

OBJECTS = main.o wav-file.o

INCFLAGS = -I include

LDFLAGS = -Wl,-rpath-link,/usr/local/lib #-L/usr/lib/scilab

LIBS =# -lscilab

all: parseSpeech

parseSpeech: $(OBJECTS)

		$(CC) -o parseSpeech $(OBJECTS) $(LDFLAGS) $(LIBS)

main.o : main.cc

		$(CC) $(CFLAGS) $(MACRO) $(INCFLAGS) $&lt; -o $@

wav-file.o : wav-file.cc

		$(CC) $(CFLAGS) $(MACRO) $(INCFLAGS) $&lt; -o $@

#wave_out.o : wave_out.cc

#	$(CC) $(CFLAGS) $(MACRO) $(INCFLAGS) $&lt; -o $@

#.SUFFIXES:	.c .cc .C .cpp .o

#.c.o :

#	$(CC) -o $@ -c $(CFLAGS) $&lt; $(INCFLAGS)

count:

	wc *.c *.cc *.C *.cpp *.h *.hpp

clean:

	rm -f *.o

.PHONY: all

.PHONY: count

.PHONY: clean&lt;/pre&gt;

[/sourcecode]
<h2>wav-def.h file</h2>
Well, to understand it, you have to see the WAV file format.

[sourcecode language="c"]

/*

 * =====================================================================================

 *

 *       Filename:  wave_def.h

 *

 *    Description:  Header of wav file.

 *

 *        Version:  1.0

 *        Created:  Thursday 14 October 2010 12:40:38  IST

 *       Revision:  none

 *       Compiler:  g++/gcc

 *

 *         Author:  Dilawar (nuts), dilawar[AT]ee[dot]iitb[dot]ac[dot]in

 *      Institute:  Indian Institute of Technology, Bombay

 *

 * This material is released under GNU Lesser Public License.

 * You are free to copy, distribute or use it for any non-commercial activity.

 * But you are not allowed to modify it. If you are a student, you can use its

 * part in your work with or without mentioning it.

 *

 * For additional details, please see the GNU Lesser Public license.

 *

 * NOTE : No propriety software is used in this material.

 * Almost all of the code is written and modified in VIM editor with c-support

 * plugin which is more awesome than Kung Fu Panda. Just kidding, no one is more

 * awesome than Kung Fu Panda with or without a light saber.

 *

 * This program is made using a bit for here,  a bit from there under the influence

 *  of a lot of burnt out neurons.

 * Report bugs : dilawar.in@gmail.com

 * =====================================================================================

 */

#ifndef  wave_def_INC

#define  wave_def_INC

/* this implementation is due to Fred De Piero - CalPoly State University.

 * Released under GNU Public Licence.

 * Used without his permossion or knowledge.

 * Modifications are done to suit our purpose. And this part was not trivial.

 * This is NOT a copy and paste implementation.

 */

typedef struct{

    char rID[4];      // 'RIFF'

    long int rLen;

    char wID[4];      // 'WAVE'

    char fId[4];      // 'fmt'

    long int pcmHeaderLength;

    short int wFormatTag;

    short int numChannels;

    long int nSamplesPerSec;

    long int nAvgBytesPerSec;

    short int numBlockAlingn;

    short int numBitsPerSample;

} WAV_HDR;

/* header of wave file */

typedef struct

{

    char dId[4];  // 'data' or 'fact'

    long int dLen;

} CHUNK_HDR;

#endif   /* ----- #ifndef wave_def_INC  ----- */

[/sourcecode]
<h2>wav-file.h file</h2>
[sourcecode language="c"]

/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */

/*

 * project_hindi

 * Copyright (C) Dilawar Singh 2010

 *

 * project_hindi is free software: you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the

 * Free Software Foundation, either version 3 of the License, or

 * (at your option) any later version.

 *

 * project_hindi is distributed in the hope that it will be useful, but

 * WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 * See the GNU General Public License for more details.

 *

 * You should have received a copy of the GNU General Public License along

 * with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

 */

#ifndef _WAV_FILE_H_

#define _WAV_FILE_H_

#include &lt;iostream&gt;

#include &lt;iomanip&gt;

#include &lt;cmath&gt;

#ifndef  CONST84

#define CONST84       /* -----  not CONST84  ----- */

#endif     /* -----  not CONST84  ----- */

/*

 * =====================================================================================

 *        Class:  WavFile

 *  Description:  This file is responsible for loading wav file and reading

 *  its content. Wav file data will be loaded into some dat file to be

 *  processed later.

 * =====================================================================================

 */

class WavFile

{

    private:

        bool isExist;

        bool isOpen;

        bool isClose;

        char* fileName;

    public:

        /* ====================  LIFECYCLE     ======================================= */

        WavFile ();                             /* constructor      */

        //WavFile ( char* fileName );   /* copy constructor */

        ~WavFile ();                            /* destructor       */

        /* ====================  ACCESSORS     ======================================= */

        /*

         * ===  FUNCTION  ======================================================================

         *         Name:  getNumSamples

         *  Description:  Returns number of samples in file.

         * =====================================================================================

         */

        long int getNumSamples();

        /*

         * ===  FUNCTION  ======================================================================

         *         Name:  getNumChannels

         *  Description:  Returns no of channels (1 == mono, 2 == stereo )

         * =====================================================================================

         */

        int getNumChannels();

        /*

         * ===  FUNCTION  ======================================================================

         *         Name:  getBitsPerSample

         *  Description:  Report the number of bits in each samples.

         * =====================================================================================

         */

        int getBitsPerSample();

        /*

         * ===  FUNCTION  ======================================================================

         *         Name:  getSampleRateHz

         *  Description:  return sample rate in Hz

         * =====================================================================================

         */

        double getSampleRateHz();

        /*

         * ===  FUNCTION  ======================================================================

         *         Name:  displayInformation

         *  Description:  get all the information about file.

         * =====================================================================================

         */

        int displayInformation(char* fileName);

        /* ====================  MUTATORS      ======================================= */

        /* ====================  OPERATORS     ======================================= */

        /*

         * ===  FUNCTION  ======================================================================

         *         Name:  readCurrentInput()

         *  Description:  Routine for reading one sample from a previously

         *  loaded wave file. Retuens current sample as a double.

         * =====================================================================================

         */

        double readCurrentInput();

        /*

         * ===  FUNCTION  ======================================================================

         *         Name:  ifMoreDataAvailable

         *  Description:  Check if file is over.

         * =====================================================================================

         */

        int ifMoreDataAvailable();

        //const WavFile&amp; operator = ( const WavFile &amp;other ); /* assignment operator */

        /* ====================  DATA MEMBERS  ======================================= */

    protected:

        double fs_hz;

        int bitsPerSample;

        int nChannel;

        double* gWavDataIn;

        int numInSamples;

        long int maxInSamples;

        /* put friends here if he has any else, leave him all alone you crazy objects */

    public:

        /*

         * ===  FUNCTION  ======================================================================

         *         Name:  openWavFile

         *  Description:  This will open the wav file for further processing.

         * =====================================================================================

         */

        int openWavFile(char* fileName);

        /*

         * ===  FUNCTION ======================================================================

         *         Name:  loadWavData

         *  Description:  This should load the content of wav file in to a

         *  binary file for further processing.

         * =====================================================================================

         */

        int writeDataToFile();

        /*

         *--------------------------------------------------------------------------------------

         *       Class:  WavFile

         *      Method:  closeWavFile

         * Description:  This should close the file after processing.

         *--------------------------------------------------------------------------------------

         */

        int closeWavFile(FILE* pFile);

}; /* -----  end of class WavFile  ----- */

#endif // _WAV_FILE_H_

[/sourcecode]
<h2>wave-file.cc</h2>
[sourcecode language="c"]

/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */

/*

 * project_hindi

 * Copyright (C) Dilawar Singh 2010

 *

 * project_hindi is free software: you can redistribute it and/or modify it

 * under the terms of the GNU General Public License as published by the

 * Free Software Foundation, either version 3 of the License, or

 * (at your option) any later version.

 *

 * project_hindi is distributed in the hope that it will be useful, but

 * WITHOUT ANY WARRANTY; without even the implied warranty of

 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 * See the GNU General Public License for more details.

 *

 * You should have received a copy of the GNU General Public License along

 * with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.

 */

#include &quot;./../include/wav-file.h&quot;

#include	&quot;./../include/wav-def.h&quot;

#include  &lt;string.h&gt;

#include	&lt;stdio.h&gt;

#include	&lt;stdlib.h&gt;

#include	&lt;math.h&gt;

/* constructor */

WavFile::WavFile()

{

#ifdef  DEBUG

    printf(&quot;\ninside WavFile()&quot;);

#endif     /* -----  not DEBUG  ----- */

}		/* -----  end of method WavFile::WavFile  ----- */

/* deconstructor */

WavFile::~WavFile()

{

#ifdef  DEBUG

    printf(&quot;\n~WavFile()&quot;);

#else      /* -----  not DEBUG  ----- */

#endif     /* -----  not DEBUG  ----- */

}

/*

 *--------------------------------------------------------------------------------------

 *       Class:  WavFile

 *      Method:  getNumSamples

 * Description:  returns num of sample in file.

 *--------------------------------------------------------------------------------------

 */

long int WavFile::getNumSamples()

{

    return maxInSamples;

}

/*

 *--------------------------------------------------------------------------------------

 *       Class:  WavFile

 *      Method:  getNumChannels

 * Description:  get number of channels present in wav file. 1 is mono, 2 is

 * stereo. Get in pal!

 *--------------------------------------------------------------------------------------

 */

int WavFile::getNumChannels()

{

    return nChannel;

}

/*

 *--------------------------------------------------------------------------------------

 *       Class:  WavFile

 *      Method:  getBitsPerSample

 * Description:  You know. Return bit per sample.

 *--------------------------------------------------------------------------------------

 */

int WavFile::getBitsPerSample()

{

    return bitsPerSample;

}

/*

 *--------------------------------------------------------------------------------------

 *       Class:  WavFile

 *      Method:  getSampleRate

 * Description:  get sample rate in chunk.

 *--------------------------------------------------------------------------------------

 */

double WavFile::getSampleRateHz()

{

    return fs_hz;

}

/*

 *--------------------------------------------------------------------------------------

 *       Class:  WavFile

 *      Method:  ifMoreDataAvailable

 * Description:  check if something is left in file.

 *

 *--------------------------------------------------------------------------------------

 */

int WavFile::ifMoreDataAvailable()

{

    if(numInSamples &gt;= maxInSamples)

    {

        return 0;

    }

    return 1;

}

/*

 *--------------------------------------------------------------------------------------

 *       Class:  WavFile

 *      Method:  readCurrentInput

 * Description:  Isn't it obvious from the file.

 *--------------------------------------------------------------------------------------

 */

double WavFile::readCurrentInput()

{

    if( (gWavDataIn == NULL) || (maxInSamples &lt;=0) || (numInSamples &lt; 0) )

    {

        printf(&quot;\nInput file not ready (or not loaded) !!!\n&quot;);

        exit(1);

    }

    if( numInSamples &gt;= maxInSamples)

    {

        printf(&quot;What you reading. Nothing is left to read, you crazy book-worm!!&quot;);

        exit(1);

    }

    return gWavDataIn[numInSamples++];

}

/*

 *--------------------------------------------------------------------------------------

 *       Class:  WavFile

 *      Method:  WavFile

 * Description:  this is another constructor which reads the file.

 *--------------------------------------------------------------------------------------

 */

int WavFile::openWavFile(char* fileName)

{

#ifdef  DEBUG

    printf(&quot;\nopenWavFile function&quot;);

#endif     /* -----  not DEBUG  ----- */

    int i;

    //printf(&quot;Inside function.&quot;);

    FILE *pFile;

    unsigned int stat;

    char outBuffer[80];

    WAV_HDR* pWavHeader;

    CHUNK_HDR* pChunkHeader;

    short int* pU;

    unsigned char* pC;

    int sFlag;

    long int rMore;

    char* wBuffer;

    int wBufferLength;

    /* set the defaults values. */

    gWavDataIn = NULL;

    numInSamples = 0;

    maxInSamples = 0;

    /* allocate wav header */

    pWavHeader = new WAV_HDR;

    pChunkHeader = new CHUNK_HDR;

    if( NULL == pWavHeader )

    {

        printf(&quot;can't new headers\n&quot;);

        exit(-1);

    }

    if( NULL == pChunkHeader )

    {

        printf(&quot;can't new headers\n&quot;);

        exit(-1);

    }

    /*

     * open the wav file

     */

    pFile = fopen( fileName, &quot;rb&quot;);

    if(pFile == NULL)

    {

        printf(&quot;Can't open wav file.&quot;);

        exit(-1);

    }

    /*-----------------------------------------------------------------------------

     *  Now, we have load the file. Start reading data.

     *-----------------------------------------------------------------------------*/

    /* read riff/wav header */

    stat = fread((void*) pWavHeader, sizeof(WAV_HDR), (size_t)1, pFile);

    if(stat != 1)

    {

        printf(&quot;Header missing. May be format is not OK!\n&quot;); // This is tested.

        exit(-1);

    }

    /* check format of header */

    for(i = 0; i &lt; 4; i++)

    {

        outBuffer[i] = pWavHeader-&gt;rID[i];

    }

    outBuffer[4] = 0;

    if(strcmp(outBuffer, &quot;RIFF&quot;) != 0) // tested.

    {

        printf(&quot;\nBad RIFF format. I am not cool enough to support everything&quot;);

        printf(&quot;\nyou provide us with! Give me a good file.&quot;);

        exit(-1);

    }

    for(i = 0; i &lt; 4; i++)

    {

        outBuffer[i] = pWavHeader-&gt;wID[i];

    }

    outBuffer[4] = 0;

#ifdef DEBUG1

    std::cout&lt;&lt;&quot;\noutBuffer: &quot;&lt;&lt;&lt;&quot;and fID:&quot;&lt;fId;

#else      /* -----  not &gt;DEBUG  ----- */

#endif     /* -----  not &gt;DEBUG  ----- */

    if(strcmp(outBuffer, &quot;WAVE&quot;) != 0) // tested.

    {

        printf(&quot;\nBad WAVE format&quot;);

        exit(-1);

    }

    for(i = 0; i &lt; 4; i++)

    {

        outBuffer[i] = pWavHeader-&gt;fId[i];

    }

    outBuffer[4] = 0;

#ifdef DEBUG1

    std::cout&lt;&lt;&quot;outBuffer:&quot;&lt;

    std::cout&lt;&lt;&quot;compare:&quot;&lt;&lt;strcmp(outBuffer, &quot;fmt &quot;);

#endif     /* -----  not &gt;DEBUG  ----- */

    if(strcmp(outBuffer, &quot;fmt &quot;) != 0) // not with &quot;fmt&quot; since 4th pos is blank

    {

        printf(&quot;\nBad fmt format&quot;);

        exit(-1);

    }

    if(pWavHeader-&gt;wFormatTag != 1)

    {

        printf(&quot;\n Bad wav wFormatTag&quot;);

        exit(-1);

    }

    if( (pWavHeader-&gt;numBitsPerSample != 16) &amp;&amp; (pWavHeader-&gt;numBitsPerSample != 8))

    {

        printf(&quot;\nBad wav bits per sample&quot;);

    }

    /*

     * Skip over any remaining portion of wav header.

     */

    rMore = pWavHeader-&gt;pcmHeaderLength - (sizeof(WAV_HDR) - 20);

    if( 0 != fseek(pFile, rMore, SEEK_CUR))

    {

        printf(&quot;Can't seek.&quot;);

    }

    /*

     * read chunk untill a data chunk is found.

     */

    sFlag = 1;

    while(sFlag != 0)

    {

        // check attempts.

        if(sFlag &gt; 10) { printf(&quot;\nToo manu chunks&quot;); exit(-1);}

        // read chunk header

        stat = fread((void*)pChunkHeader, sizeof(CHUNK_HDR), (size_t)1, pFile);

        if( 1 != stat)

        {

            printf(&quot;\n I just can't read data. Sorry!&quot;);

            exit(-1);

        }

        // check chunk type.

        for(i =0; i &lt; 4; i++)

        {

            outBuffer[i] = pChunkHeader-&gt;dId[i];

        }

        outBuffer[4] = 0;

        if(strcmp(outBuffer, &quot;data&quot;) == 0) { break;}

        // skip over chunk.

        sFlag++;

        stat = fseek(pFile, pChunkHeader-&gt;dLen, SEEK_CUR);

        if(stat != 0)

        {

            printf(&quot;Can't seek.&quot;);

            exit(-1);

        }

    }

    /* find length of remaining data. */

    wBufferLength = pChunkHeader-&gt;dLen;

#ifdef  DEBUG1

    std::cout&lt;&lt;&quot;wBufferLength:&quot;&lt;

#endif     /* -----  not DEBUG  ----- */

    /* find number of samples. */

    maxInSamples = pChunkHeader-&gt;dLen;

    maxInSamples /= pWavHeader-&gt;numBitsPerSample/8;

    /* allocate new buffers */

    wBuffer = new char[wBufferLength];

    if( wBuffer == NULL)

    {

        printf(&quot;\nCan't allocate.&quot;); exit(-1);

    }

    gWavDataIn = new double[maxInSamples];

    if(gWavDataIn == NULL)

    {

        printf(&quot;Can't allocate\n&quot;); exit(-1);

    }

    /* read signal data */

    stat = fread((void*)wBuffer, wBufferLength, (size_t)1, pFile);

    if( 1 != stat)

    {

        printf(&quot;\nCan't read buffer.&quot;);

        exit(-1);

    }

    /* convert data */

    if(pWavHeader-&gt;numBitsPerSample == 16)

    {

        pU = (short*) wBuffer;

        for( i = 0; i &lt; maxInSamples; i++)

        {

            gWavDataIn[i] = (double) (pU[i]);

        }

    }

    else

    {

        pC = (unsigned char*) wBuffer;

        for( i = 0; i &lt; maxInSamples; i++)

        {

            gWavDataIn[i] = (double) (pC[i]);

        }

    }

#ifdef  DEBUG11

    for( i = 0; i &lt; maxInSamples; i++)

    {

        printf(&quot;%d:%f\t&quot;,i, gWavDataIn[i]);

    }

#endif     /* -----  not DEBUG  ----- */

    /*

     * save all this.

     */

   fs_hz = (double) (pWavHeader-&gt;nSamplesPerSec);

   bitsPerSample = pWavHeader-&gt;numBitsPerSample;

   nChannel = pWavHeader-&gt;numChannels;

  /* reset and delete */

   numInSamples = 0;

   if(wBuffer != NULL) delete wBuffer;

   if(pWavHeader != NULL) delete pWavHeader;

   if(pChunkHeader != NULL) delete pChunkHeader;

   fclose(pFile);

   return EXIT_SUCCESS;

}

int WavFile::displayInformation(char* fName)

{

#if 1

   /*

    * print the data.

    */

   printf(&quot;\n-----------------------------------------------------&quot;);

   printf(&quot;\nLoaded wav file : %s&quot;, fName);

   printf(&quot;\nSample rate: %1.01f (Hz)&quot;, fs_hz);

   printf(&quot;\nNumber of samples = %ld&quot;, maxInSamples);

   printf(&quot;\nBits per sample = %d&quot;, bitsPerSample);

   printf(&quot;\nNumber of channels = %d&quot;, nChannel);

   printf(&quot;\n----------------------------------------------------\n&quot;);

#endif

  return EXIT_SUCCESS;

}

int WavFile::writeDataToFile()

{

    FILE* pFile;

    pFile = fopen(&quot;speechData.txt&quot;, &quot;w&quot;);

    for( int i = 0; i &lt; maxInSamples; i++)

    {

       char data[30];

       int n;

       n = sprintf(data,&quot;%d\t%1.01f\n&quot;,i,gWavDataIn[i]);

       //pData = gWavDataIn[i];

       fprintf(pFile, data);

       //std::cout&lt;&lt;data;

    }

    fclose(pFile);

    return EXIT_SUCCESS;

}

[/sourcecode]
<h2>main.cc</h2>
[sourcecode language="c"]

/*

 * =====================================================================================

 *

 *       Filename:  main.cc

 *

 *    Description:  This is our main file.

 *

 *        Version:  1.0

 *        Created:  Sunday 05 September 2010 09:44:39  IST

 *       Revision:  none

 *       Compiler:  g++/gcc

 *

 *         Author:  Dilawar (nuts), dilawar[AT]ee[dot]iitb[dot]ac[dot]in

 *      Institute:  Indian Institute of Technology, Bombay

 *

 * This material is released under GNU Lesser Public License.

 * You are free to copy, distribute or use it for any non-commercial activity.

 * But you are not allowed to modify it. If you are a student, you can use its

 * part in your work with or without mentioning it.

 *

 * For additional details, please see the GNU Lesser Public license.

 *

 * NOTE : No propriety software is used in this material.

 * Almost all of the code is written and modified in VIM editor with c-support

 * plugin which is more awesome than Kung Fu Panda. Just kidding, no one is more

 * awesome than Kung Fu Panda with or without a light saber.

 *

 * This program is made using a bit for here,  a bit from there under the influence

 *  of a lot of burnt out neurons.

 * Report bugs : dilawar.in@gmail.com

 * =====================================================================================

 */

#define EXIT_SUCCESS    1

#define EXIT_FAILURE    0

#define TRUE            1

#define FALSE           0

#include	&quot;include/wav-file.h&quot;

//#include	&quot;praat.h&quot;

//#include  &quot;Printer.h&quot;

#include

#ifdef SCILAB

#include	&quot;scilab/stack-c.h&quot;

#include	&quot;scilab/api_scilab.h&quot;

#include	&quot;scilab/call_scilab.h&quot; /* Provide function to call scilab. */

#endif

#if 0

wchar_t myScript [] = L&quot;&quot;

      &quot;demo Text... 0.5 centre 0.5 half Hello world\n&quot;

      &quot;demoWaitForInput()\n&quot;

      ;

#endif

int main(int argc, char** argv)

{

#if DEBUG

	std::cout&amp;lt;&amp;lt;&amp;quot;Entering the main()\n&amp;quot;;

	std::cout&lt;&lt;&quot;\nNo of args are: &quot;&lt;&lt;argc;

#endif

	/* Here, we parse our argument passed to this application from command line*/

	if(argc &lt; 2)

	{

		std::cout&amp;lt;&amp;lt;&amp;quot;\nOh Snap!&amp;quot;

			&amp;lt;&amp;lt;&amp;quot;\nWassup, Fellow Human..&amp;quot;

			&amp;lt;&amp;lt;&amp;quot;\nAt least, you need to specify wav file. Use --help to see your options.\n&amp;quot;;

	 	return EXIT_FAILURE;

	}

  int c;

  unsigned long long int number;

	int do_help = 0;

 	int do_verbose = 0;

 	bool ifInvalid = FALSE;	/* flag variables. */

	char* fileName;

	while(1)

	{

		int option_index = 0;

		static struct option long_options[] = {

			{&amp;quot;file&amp;quot;, 		required_argument, 		NULL, 		'f'},

			{&amp;quot;help&amp;quot;, 			no_argument, 		 			&amp;amp;do_help, 	1},

			{&amp;quot;verbose&amp;quot;, 	no_argument, 				 	&amp;amp;do_verbose, 1},

			{0, 0, 0 , 0}

		};

		c = getopt_long(argc, argv, &quot;f:hv&quot;, long_options, &amp;option_index);

		if (c == -1)

			break;

		switch(c) {

			case 'f':

#if DEBUG

				std::cout&amp;lt;&amp;lt;&amp;quot;\nFrom main() - Option --file with value '&amp;quot;

					&lt;&lt;optarg&lt;&lt;&quot;'\n&quot;;

#endif

				fileName = optarg;

				break;

			case 0:

#ifdef DEBUG

				std::cout&amp;lt;&amp;lt;&amp;quot;\noption &amp;quot;&amp;lt;&amp;lt;long_options[option_index].name;

				if (optarg)

					std::cout&amp;lt;&amp;lt;&amp;quot;with arg &amp;quot;&amp;lt;&amp;lt;optarg;

				//std::cout&lt;&lt;&quot;Bad option. x-(\n&quot;;

#endif

				break;

			case 'v':

			  do_verbose = 1;

#ifdef  DEBUG

				std::cout&amp;lt;&amp;lt;&amp;quot;\nFrom main() : Verbose output is set.\n&amp;quot;;

#else      /* -----  not DEBUG  ----- */

#endif     /* -----  not DEBUG  ----- */

				break;

			case 'h':

				do_help = 1;

				break;

			case ':': /* missing option arguement. */

				fprintf(stderr, &quot; option %s requires an argument. \n&quot;,

						argv[1]);

				ifInvalid = TRUE;

			 	break;

			case '?':

			default:

				fprintf(stderr, &quot;option %s is invalid : ignored\n&quot;,

						argv[1]);

				ifInvalid = TRUE;

				break;

		}

	}

	/* We got the options. Do the stuff. */

	if(TRUE == ifInvalid || 1 == do_help)

	{

		std::cout&amp;lt;&amp;lt;&amp;quot;\n-------------------------------------------------------&amp;quot;;

		std::cout&amp;lt;&amp;lt;&amp;quot;\nUSAGE :&amp;quot;;

		std::cout&amp;lt;&amp;lt;&amp;quot;\n\t --file &quot;

			&lt;&lt;&quot;\n\t\t provide the wav file.&quot;

			&amp;lt;&amp;lt;&amp;quot;\n\t --help&amp;quot;

			&amp;lt;&amp;lt;&amp;quot;\n\t\t to see the help. Should be used alone.&amp;quot;

			&amp;lt;&amp;lt;&amp;quot;\n\t --verbose&amp;quot;

			&amp;lt;&amp;lt;&amp;quot;\n\t\t for verbose output.&amp;quot;;

		std::cout&amp;lt;&amp;lt;&amp;quot;\n-------------------------------------------------------\n&amp;quot;;

		return EXIT_FAILURE;

	}

  WavFile* pObjWavFile;

  std::cout&lt;&lt;&quot;FileName is:&quot;&lt;openWavFile(fileName))

  {

      std::cout&lt;displayInformation(fileName);

  /* read data */

#if 0

  while(pObjWavFile-&gt;ifMoreDataAvailable())

  {

      double data = pObjWavFile-&gt;readCurrentInput();

      std::cout&lt;&lt;&quot;\t&quot;&lt;writeDataToFile();

/*

 * THIS IS PRAAT BLOCK.

 */

#ifdef PRAAT

  praat_setStandAloneScriptText (myScript);

  praat_init (&quot;Hello&quot;, argc, argv);

  INCLUDE_LIBRARY (praat_uvafon_init)

  praat_run ();

#endif

  /*

   * THIS IS SCILAB BLOCK

   */

#ifdef  SCILAB11

/**

 * Initialization.

 */

#ifdef _MSC_VER

  if(StartScilab(NULL, NULL, NULL) == FALSE)

#else

  if(StartScilab(getenv(&quot;SCI&quot;), NULL, NULL) == FALSE)

#endif

  {

      fprintf(stderr, &quot;Error while calling StartScilab\n&quot;);

      return -1;

  }

#else      /* -----  not SCILAB  ----- */

#endif     /* -----  not SCILAB  ----- */

 /*

  *  Write the file name into Scilan

 */

     int row = 1, col = 1;

#ifdef SCILAB

     /* Declare the string */

     char **myMatrixOfFilePath = (char**)malloc(sizeof(char*)*row*col);

     myMatrixOfFilePath[0] = fileName;

     std::cout&lt;&lt;&quot;path is : &quot;&lt;&lt;myMatrixOfFilePath[0];

     char variableName[]= &quot;filePath&quot;;

     /* write it into scilab memory */

     createNamedMatrixOfString(pvApiCtx, variableName, row, col, myMatrixOfFilePath);

#ifdef  DEBUG

    std::cout&lt;&lt;&quot;variable name is :&quot;&lt;&lt;variableName;//&lt;&lt;&quot; and :&quot; &lt;&lt;filePath;

#else      /* -----  not DEBUG  ----- */

#endif     /* -----  not DEBUG  ----- */

     /* now send this job to Scilab */

      SendScilabJob(&quot;myMatrix = [1 2 3; 2 3 1];&quot;);

      SendScilabJob(&quot;disp(myMatrixOfFilePath)&quot;);

      SendScilabJob(&quot;disp(filePath);&quot;);

      SendScilabJob(&quot;[x, y] = loadWave(filePath);&quot;);

      SendScilabJob(&quot;disp(x);&quot;);

      /*-----------------------------------------------------------------------------

       *  Termination

       *-----------------------------------------------------------------------------

       */

      if(TerminateScilab(NULL) == FALSE)

      {

          fprintf(stderr, &quot;Error while closing scilab.&quot;);

          return -2;

      }

#endif // SCILAB

      return 0;

    }

[/sourcecode]
<h1>Results</h1>
[slideshow]

</CONTENT>

<POST_TAG ID="23">c++</POST_TAG>

<CATEGORY ID="11">Programming</CATEGORY>

<POST_TAG ID="24">programming</POST_TAG>

<POST_TAG ID="25">speech processing</POST_TAG>

<CATEGORY ID="5">Technology and Engineering</CATEGORY>

<POST_TAG ID="26">WAV file format</POST_TAG>
