<TYPE>post</TYPE>
<STATUS>publish</STATUS>
<ID>220</ID>
<TITLE>
Enumerate path in a circuit
</TITLE>

<CONTENT>
Consider the following circuit and its directed graph. Directed graphs can represent many things. In our case though, it represent a digital circuit as shown below. Consider each node of the graph as a logical gate of the circuit. The incoming edges are input to the logic gate and outgoing edges are the output of the logic gate.

[caption id="attachment_224" align="aligncenter" width="663" caption="Circuit is drawn in Qucs simulator which I think will be of great value in near future."]<a href="http://dilawarnotes.files.wordpress.com/2010/10/assign4.png"><img class="size-large wp-image-224    " title="A digital Circuit " src="http://dilawarnotes.files.wordpress.com/2010/10/assign4.png?w=1024" alt="" width="663" height="468" /></a>[/caption]
<p style="text-align:left;">Following figure shows its directed graph. Buffer Y9 and Y10 are ignored since they were inserted to distinguish u_1 from p_00 etc. Now if we need to test this circuit for path delays, we need to enumerate the path firsts. After converting the circuit into a graph, enumeration the path is a routine problem and can be solved by using <strong>Depth First Search</strong> algorithm. An <em>edge</em> from one node to other shows that a <em>wire</em> exists between them. By <em>path</em> we mean this <em>wire</em> only.</p>
The path is shown below. <strong>dot </strong> Tool is used to generate this graph. Now the problem is reduced to enumerating the path between input and output.﻿ This can be done using the standard <strong>Depth First Search (DFS). </strong>The procedure is following.

[caption id="attachment_223" align="alignleft" width="218" caption="Figure representing a digital circuit."]<a href="http://dilawarnotes.files.wordpress.com/2010/10/graph1.png"><img class="size-medium wp-image-223" title="graph1" src="http://dilawarnotes.files.wordpress.com/2010/10/graph1.png?w=218" alt="" width="218" height="300" /></a>[/caption]
<ul>
	<li><strong>Partition the graph</strong> We partition nodes of the given graph $latex G(E,V)$ in to two sets namely $latex V_{input}$ and $latex V_{output}$.</li>
	<li>Clearly, $latex  V_{input} \bigcup V_{output} \subset V$. We may have a trivial case in which $latex V_{input} \bigcup V_{output} \subseteq V$. Clearly, the number of path in this situation is equal to the number of edges in $latex G$. In our problem we are already been provided with $latex V_{input} = \{a , b\} $ and $latex V_{output} = \{u_1, u_2, u_3, u_4\}$.</li>
	<li><strong>Step 1</strong> Start from a node $latex V_i \in V_{input}$. Mark this node as<em>used</em>. Initialize counter to 0. Initialize stack to keep track of path.</li>
	<li><strong>Step 2</strong> Pick an edge and reach to the next connected node. Push this edge on the stack. Do it till you hit a node which belongs to $latex V_{output}$. Increase counter by 1.</li>
	<li><strong>Step 3</strong> Pop the stack and traceback your path. Do it till you meet a node which have an edge which has not been pushed on to the stack. When you get this node. Repeat step 2. Else go to step 4.</li>
	<li><strong>Step 4</strong> Counter will give you the number of path between input node $latex V-i$ and the output nodes. If there are nodes left in $latex V_{input}$, go to step 1. Else go to step 5.</li>
	<li><strong>Step 5</strong> Each input node have a counter value. Add them up. This gives the total number of path in the circuit.﻿ ﻿</li>
</ul>
Now these steps can be visualized easily. We start from node <strong>a </strong>and traverse this graph.

[caption id="attachment_227" align="aligncenter" width="592" caption="Start from a and enumerate all the paths ending at the nodes starting with u. We have total of 6 paths. As we hit an dead end, we increase the number of path by one. The numerics displayed at the end of node represent this only. Edges with label 0 shows that this is the first path we have taken. For examplem a-&gt;w-&gt;p00-&gt;u1 is one path. We push these nodes on a stack. We increase the path number as we hit u1 since it belongs to the end point. From here we trace back to hunt down the rest of the paths which are shown by blue edges. This trace-backing is most naturally implemented using stack. Any node name prefixed with p_  represents pop operation on the stack. Here, from u1 we got to p_u1 which mean that pop u1. We reach p00 and we know that there is one edge we have not traversed since it was not in the stack. Now p00-&gt;u2 is one more path and we increase the path by one (path = 2 now). We traceback through p_u2-&gt;p_p01-&gt;p-w (pop u2, p01, and w) and reach a to find a new edge p11 to be traversed. So on and so forth, we enumerate all the paths. We should label every edge with label path_value so that we can keep track of the paths."]<a href="http://dilawarnotes.files.wordpress.com/2010/10/path11.png"><img class="size-full wp-image-227 " title="path1" src="http://dilawarnotes.files.wordpress.com/2010/10/path11.png" alt="" width="592" height="536" /></a>[/caption]

In the same way, we can enumerate all the paths from input node <strong>b </strong>to the output nodes.
<p style="text-align:center;">&nbsp;</p>


[caption id="attachment_228" align="aligncenter" width="615" caption="Path from node b to output. The procedure is explained in the previous figure. Here also we get 6 paths."]<a href="http://dilawarnotes.files.wordpress.com/2010/10/path2.png"><img class="size-full wp-image-228  " title="path2" src="http://dilawarnotes.files.wordpress.com/2010/10/path2.png" alt="" width="615" height="421" /></a>[/caption]
<p style="text-align:left;">Well, we used graphviz to generate these graphs. We give these scripts.</p>
<p style="text-align:left;">&nbsp;</p>

[sourcecode language="css"]
&amp;lt;p style=&amp;quot;text-align: left;&amp;quot;&amp;gt;digraph G {
 node[fontzise = 10, width=&quot;0.4&quot;, height = &quot;0.4&quot;, margin = 0];
 edge[color=red]
subgraph cluster001{
 style = filled;
 color = lightgrey;
 node [style= filled, color=white]
start [shape = box];
start -&gt; a [penwidth = 4, headlabel = 0];
a -&amp;gt; w [label = 0];
 w -&gt; p00 [label = 0];
 p00 -&gt; u1[label = 0, headlabel=&quot;1&quot;];
 p00 -&gt; u2 [headlabel=&quot;2&quot;];
 w -&gt; p01;
 p01 -&gt; u3[headlabel = 3];
 a -&gt; p11;
 p11 -&gt; u2 [headlabel =4];
 p11 -&gt; u4 [headlabel = 5];
 a -&gt; p10;
 p10 -&gt; u3 [headlabel = 6];
}
subgraph cluster002{
style=filled;
color=pink;
edge [color = blue]
u1 -&gt; p_u1;
//p_u1 -&amp;gt; p_p00;
p_u1 -&gt; p00;
u2 -&gt; p_u2;
p_u2 -&gt; p_p00;
p_p00 -&gt; w;
///
u3 -&gt; p_u3;
p_u3 -&gt; p_p01;
p_p01 -&gt; p_w;
p_w -&amp;gt; a;
//
//
u4 -&gt; p_u4;
p_u4 -&gt; p_p11;
p_p11 -&gt; a;
//
}
subgraph cluster004{
style=filled;
color=pink;
edge [color = blue]
u3 -&gt; p_u3_;
p_u3_ -&amp;gt; p_p10_;
p_p10_ -&gt; a [headlabel = &quot;END&quot;];
u2 -&gt; p_u2_;
p_u2_ -&gt; p11;

}

subgraph cluster004{
 p00; p01; p11; p10;
}
 subgraph cluster03{
 style = filled;
 color = lightgrey;
 node [style= filled, color=white]
 u1; u2; u3; u4;
 }

}


[/sourcecode]

[sourcecode language="css"]
digraph G {

 node[fontzise = 10, width=&quot;0.4&quot;, height = &quot;0.4&quot;, margin = 0];
 edge[color=red]

subgraph cluster001{
 style = filled;
 color = lightgrey;
 node [style= filled, color=white]
 start [shape = box];
 start -&gt; b [penwidth = 4, headlabel = 0];
 b -&gt; x [label = 0];
 x -&gt; p00 [label = 0];
 p00 -&gt; u1[label = 0, headlabel=&quot;1&quot;]; // pop
 p00 -&gt; u2 [headlabel=&quot;2&quot;];// pop
 x -&gt; p10;
 p10 -&gt; u3[headlabel = 3]; // pop
 b -&gt; p01;
 p01 -&gt; u3 [headlabel =4]; // pop
 b -&gt; p11;
 p11 -&gt; u2 [headlabel = 5]; // pop
 p11 -&gt; u4 [headlabel = 6]; // pop
}
subgraph clusterPOP1{
 style=filled;
 color=pink;
 edge [color = blue]
 u1 -&gt; p_u1;
 p_u1 -&gt; p00;// Go forward.
 u2 -&gt; p_u2;
 p_u2 -&gt; p_p00;
 p_p00 -&gt; x; // go forward.
 u3 -&gt; p_p10;
 p_p10 -&gt; p_x;
 p_x -&gt; b; // go forward.
 u3 -&gt; p_u3;
 p_u3 -&gt; p_p01;
 p_p01 -&gt; b; // go forward.
 u4 -&gt; p_u4;
 p_u4 -&gt; p_p11;
 p_p11 -&gt; b [headlabel = &quot;EXIT&quot;];
}

subgraph clusterPOP2{
 style=filled;
 color=pink;
 edge [color = blue]
 u2 -&gt; p_u2_;
 p_u2_ -&gt; p11; // go forward.

}

subgraph cluster03{
 style = filled;
 color = lightgrey;
 node [style= filled, color=blue]
 u1; u2; u3; u4;
}
}


[/sourcecode]

</CONTENT>

<POST_TAG ID="34">depth first search</POST_TAG>

<POST_TAG ID="29">dot</POST_TAG>

<CATEGORY ID="10">Electrical Network</CATEGORY>

<CATEGORY ID="27">Graph Theory</CATEGORY>

<POST_TAG ID="33">graph theory</POST_TAG>

<POST_TAG ID="28">graphviz</POST_TAG>

<POST_TAG ID="31">path delay</POST_TAG>

<CATEGORY ID="11">Programming</CATEGORY>

<CATEGORY ID="5">Technology and Engineering</CATEGORY>

<POST_TAG ID="32">verification</POST_TAG>

<CATEGORY ID="9">VLSI</CATEGORY>

<POST_TAG ID="30">vlsi</POST_TAG>
