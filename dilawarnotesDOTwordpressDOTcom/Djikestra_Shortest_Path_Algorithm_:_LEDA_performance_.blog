<TYPE>post</TYPE>
<STATUS>draft</STATUS>
<ID>516</ID>
<TITLE>
Djikestra Shortest Path Algorithm : LEDA performance 
</TITLE>

<CONTENT>
I have written this small program using LEDA libraries (free version) and tested its performance on my machine (Pentium Core 2 Duo, 4GB RAM, Linux). Random graphs were created. For a graph with n number of nodes, number of edges could be n, 2n, or 3n.  Following is the program.

[source language="ctype"][/source]

/*
* =====================================================================================
*
*       Filename:  dikkstra.cpp
*
*    Description:  Dijksjtra algorithm for calculating shortest path.
*
*        Version:  1.0
*        Created:  Tuesday 06 December 2011 04:45:57  IST
*       Revision:  none
*       Compiler:  gcc
*
*         Author:  Dilawar Singh (Graduate Student, EE IITB), dilawar@ee.iitb.ac.in
*      Institute:  IIT Bombay
*
* =====================================================================================
*/

#include    &lt;LEDA/graph/graph.h&gt;
#include    &lt;LEDA/graph/node_pq.h&gt;

using namespace leda;
using namespace std;

/* fun : DIJKESTRA
* Args : a const graph, starting node
*        array of edges.
*        array of nodes
*/

void DIJKESTRA
( const graph &amp;G, node s,
const edge_array&lt;double&gt;&amp; cost,
node_array&lt;double&gt;&amp; dist)
{
node_pq&lt;double&gt; PQ(G); /* priority queue */
node v; edge e;

forall_nodes(v,G)
{
if (v == s)
dist[v] = 0;
else
dist[v] = MAXDOUBLE;
PQ.insert(v, dist[v]);
}

while( !PQ.empty())
{
node u = PQ.del_min();
forall_out_edges(e,u)
{
v = target(e);
double c = dist[u] + cost[e];
if(c &lt; dist[v])
{
PQ.decrease_p(v,c); dist[v] = c;
}
}
}
}


int main()
{
int n = 1; // = read_int("number of nodes = ");
int m = 1; // = read_int("number of edges = ");
graph G;
edge e;
cout &lt;&lt; "\nTime, Nodes, Edges\n";
int i;
for(i = 0; i &lt; 50000; i++)
{
random_graph(G,n,m);
edge_array&lt;double&gt; cost(G);
node_array&lt;double&gt; dist(G);
forall_edges(e,G)
cost[e] = ((double) rand_int(0,100));

float T = used_time();
DIJKESTRA(G, G.first_node(), cost, dist);
cout&lt;&lt;used_time(T)&lt;&lt;","&lt;&lt;n&lt;&lt;","&lt;&lt;m&lt;&lt;"\n";
n = (i+10)*(i+10) - 9*i;
m = rand_int(1,3)*n;
}

return 0;
}
[/sourcecode]

</CONTENT>

<CATEGORY ID="1">Uncategorized</CATEGORY>
