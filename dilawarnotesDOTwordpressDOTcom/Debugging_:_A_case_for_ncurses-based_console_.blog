<TYPE>post</TYPE>
<STATUS>publish</STATUS>
<ID>722</ID>
<TITLE>
Debugging : A case for ncurses-based console 
</TITLE>

<CONTENT>
Where would you log your debug messages when you are designing an algorithm?

I tried various things. Used various libraries (apache's log4cxx is very powerful) for logging and even used database (<a class="zem_slink" title="SQLite" href="http://sqlite.org" target="_blank" rel="homepage">sqlite3</a> is my all time favorite for this) to store all data as well as debug messages. Problem with sqlite3 is that one has to type a lot but it is a very worthy investment if one needs to process a great deal of data later. Of course, one can write test-routines in the code itself and later disable them altogether once application is tested. This seems to be a standard practise. But many times one has to look at the data by oneself and in such cases logging is essential.

One must follow a standard format while writing logging messages. Readability is of great importance. What is the use of message which are hard to read. Prettyprinting requires work and often increases the size of code. But one has to do it, there is no escape. Apache logging framework format is pretty good. One can even write logs to XML file. Beware that XML is not easy to read by humans. Computers, on the other hand, can process xml easily. If logs are too big, I'd suggest go for either XML files or sqlite3 database. SOCI's soci library is a good library in C++ for sqlite3.

For medium or small debugging, writing to simple text files or console is good enough. And one usually design his algorithm in steps. Therefore one can concentrate logs generated by a section of program. In C++, compiler macros are very useful. For example, if I am testing functionA, then I write its debug messages between <tt>#ifdef DEBUG_FUNA&nbsp;&nbsp; #endif</tt> and let the compiler know if I wants to activate or not.

I wish to suggest something more. If you are a big fan of terminal (no gui, no mouse, no problem) and have a look at <a class="zem_slink" title="Ncurses" href="http://www.gnu.org/software/ncurses/ncurses.html" target="_blank" rel="homepage">ncurses</a> library. It creates a <a class="zem_slink" title="Text-based user interface" href="http://en.wikipedia.org/wiki/Text-based_user_interface" target="_blank" rel="wikipedia">text based user interface</a> and I have used it in two applications. To cut the long story short, let me show you the screen-shot of how ncurses based screen can be split into many section in which different section can be used for different type of log messages.
<p style="text-align:center;"><a href="http://dilawarnotes.files.wordpress.com/2013/02/2013-02-17-033243_1366x768_scrot.png"><img class="aligncenter  wp-image-735" alt="2013-02-17-033243_1366x768_scrot" src="http://dilawarnotes.files.wordpress.com/2013/02/2013-02-17-033243_1366x768_scrot.png" width="637" height="358" /></a></p>
Even this is lame. Let me show you a video. First few seconds to this video will show you the blindness caused by naive logging on the console. Then we'll see the power of ncurses. You'll see two matrices, we wish the left one must have rows which has only single 1. If this is achieved, our algorithm is correct.

https://www.facebook.com/video/video.php?v=109918892526120&amp;saved

<h6 class="zemanta-related-title" style="font-size:1em;">Related articles</h6>
<ul class="zemanta-article-ul">
	<li class="zemanta-article-ul-li"><a href="http://dilawarnotes.wordpress.com/2013/01/20/processing-xml-files/" target="_blank">Processing XML files</a> (dilawarnotes.wordpress.com)</li>
</ul>

</CONTENT>

<POST_TAG ID="153">debugging with ncurses</POST_TAG>

<CATEGORY ID="152">ncurses</CATEGORY>

<POST_TAG ID="154">TUI</POST_TAG>
